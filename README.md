# csc148assignment3

overview

You will investigate the space of game sequences in order to compute metrics such as: size: How many game states, and  final game states, are there?redundancy: What portion of game states are repetitive?

your jobDownload module game state tree.py from the course website. Read the class GameStateNode, and under- stand how it's grow method is responsible for creating a tree of game states. Your  rst job is to implement grow. Next, look at the functions for analyzing game state trees, which are de ned outside the class GameS- tateNode, but in the module game state tree. Read and understand the docstring speci cation for each function, and then implement it. You may implement the functions in any order.Notice that the functions do not depend on any of the code you have written for assignment 1 or 2. They depend only on classes GameState and, in one case, class SubtractSquareState, which we have provided. Do not change either of those classes when you test your code.Many of the doctest examples are based on the example tree shown in the Assignment 2 handout for the game subtract a square. Make sure that you understand that tree fully.In all of the doctest examples, the GameStateNodes used for testing contain speci cally SubtractSquareStates. However, unless a function speci es that it only works for the game subtract a square, be prepared that we may test it on another game.

sometimes you?ll need a helperAll of the functions can be written recursively, and most or all of them would be extremely di cult and awkward to write without recursion.For some of the functions, the type contract is exactly what you need in order to conduct the recursion. In other cases, the type contract is inadequate: either the recursive call needs additional information (that isn't passed through the existing parameters) in order to do its job, or it needs to tell back additional information (that is not part of the existing return type) so that the caller can do its job. You saw this in Assignment 2, where suggest move only returned a move, but in the recursion it was necessary to report back also a score. In such situations, create a helper function that has the appropriate type contract, and call it to do most of the work.Of course, you are also welcome to use helper functions just to carve o  some of the work.If you create a helper function, pre x its name with an underscore in order to indicate that it is not intended for use by client code.using sets of game statesFor some functions, you will need to keep track of the game states that you have already seen, and to check whether a particular game state is among them. In such circumstances, you must maintain a set of game states. An alternative would be to maintain a list of game states, but checking whether an item is in a set is faster than checking whether an item is in a list. This recursion becomes crucial when there are many game states.Here is a small example of how sets work in Python:>>> s = set()>>> s.add(3)>>> s.add(55)>>> 3 in sTrue>>> 5 in sFalseIn order to make checking set membership fast, sets rely on having elements that are immutable. As a result, you cannot directly add a GameState object to a set; you must convert it to something immutable  first. This can easily be done by calling either __str__ or__repr__ .


